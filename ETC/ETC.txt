1. 16비트 구조인 스택포인터 SP 레지스터는 각각 8bit인 2개의 레지스터 SPH와 SPL로 구성되며 
이것은 각각 0x3E번지와 0x3D 번지에 위치한다.
//.cseg
//.org    0×0000                          ; initialize SP
//LDI      R17, high(RAMEND)
//LDI      R16, low(RAMEND)        ; RAMEND = 0×10FF
//OUT    SPH, R17  
//OUT    SPL, R16                       ; SPH = 0×3E, SPL = 0×3D


2.  AVR 중 다수에 내장되어 있는 hardware multiplier 의 성능과 이를 운영하는
compiler 의 능력을 꼼꼼히 분석해 본 적이 없어서 얼마나 개선이 될런지 알 수는
없으나 multiplier 를 내장하지 않은 프로세서의 경우에는 현저한 처리 속도
개선 효과가 있는 방법입니다.
100=64+32+4 가 되고 10=8+2 이므로,
    temp  = value * 100; 대신에
    temp  = (value<<6)+(value<<5)+(value<<2); 를 사용하고,
    temp  = value * 10;  대신에
    temp  = (value<<3)+(value<<1); 를 사용하는 방법입니다.
AVR 의 경우, shift 가 좀 불편한 편이므로 효과가 있는지는 모르겠습니다.

3. AVR의 경우 하드웨어 곱셈기를 가지고 있어서 엄청 빠르게 곱셈을 수행합니다. 
반면에 AVR은 비트 시프트 명령이 아주 취약합니다. 
취약하다는 것은 어느 마이크프로세서에서는 1명령으로 여러 비트를 시프트할 수 있는데 AVR은 1명령으로 1비트만을 시프트할 수 있다는 것입니다. 
따라서, 몇비트를 밀어버리려면 여러개의 명령을 사용해야 하고, 이는 곱셈명령보다도 더 오래 걸립니다.
결국 AVR에서는 이와 같이 시프트 명령을 사용하면 실행속도가 빨라지기는커녕 오히려 더 늦어질 것이 분명하다는 것입니다.


4. .equ 문자열에 상수값을 할당 (.equ TEST = 0x12)
.set 문자열에 변수값을 할당 (.equ TEST = 0x14) 값이 수시로 바뀔수 있음
.def 레지스터 이름 대신 사용할 수 있는 문자열을 정의 한다.(.def ZERO = R0) R0대신 제로라고 해도됨
.db 플래시메모리 영역에 바이트 크기 상수를 정의한다 (LIGHT .db 0xf0, 128, 0b010101010)