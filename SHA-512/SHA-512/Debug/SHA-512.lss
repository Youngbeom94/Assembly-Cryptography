
AVRASM ver. 2.2.7  C:\Asm_programing\SHA-512\SHA-512\main.asm Thu Jul 09 14:53:25 2020

[builtin](2): Including file 'C:/Program Files (x86)\Atmel\Studio\7.0\Packs\atmel\ATtiny_DFP\1.3.229\avrasm\inc\tn45def.inc'
C:\Asm_programing\SHA-512\SHA-512\main.asm(25): Including file 'C:/Program Files (x86)\Atmel\Studio\7.0\Packs\atmel\ATtiny_DFP\1.3.229\avrasm\inc\tn45def.inc'
C:\Asm_programing\SHA-512\SHA-512\main.asm(53): Including file 'C:\Asm_programing\SHA-512\SHA-512\blake_256.asm'
C:\Asm_programing\SHA-512\SHA-512\blake_256.asm(49): Including file 'C:/Program Files (x86)\Atmel\Studio\7.0\Packs\atmel\ATtiny_DFP\1.3.229\avrasm\inc\tn45def.inc'
[builtin](2): Including file 'C:/Program Files (x86)\Atmel\Studio\7.0\Packs\atmel\ATtiny_DFP\1.3.229\avrasm\inc\tn45def.inc'
C:\Asm_programing\SHA-512\SHA-512\main.asm(25): Including file 'C:/Program Files (x86)\Atmel\Studio\7.0\Packs\atmel\ATtiny_DFP\1.3.229\avrasm\inc\tn45def.inc'
C:\Asm_programing\SHA-512\SHA-512\main.asm(53): Including file 'C:\Asm_programing\SHA-512\SHA-512\blake_256.asm'
C:\Asm_programing\SHA-512\SHA-512\blake_256.asm(49): Including file 'C:/Program Files (x86)\Atmel\Studio\7.0\Packs\atmel\ATtiny_DFP\1.3.229\avrasm\inc\tn45def.inc'
                                 
                                 ;
                                 
                                 ;***** Created: 2011-02-09 12:04 ******* Source: ATtiny45.xml ************
                                 ;*************************************************************************
                                 ;* A P P L I C A T I O N   N O T E   F O R   T H E   A V R   F A M I L Y
                                 ;* 
                                 ;* Number            : AVR000
                                 ;* File Name         : "tn45def.inc"
                                 ;* Title             : Register/Bit Definitions for the ATtiny45
                                 ;* Date              : 2011-02-09
                                 ;* Version           : 2.35
                                 ;* Support E-mail    : avr@atmel.com
                                 ;* Target MCU        : ATtiny45
                                 ;* 
                                 ;* DESCRIPTION
                                 ;* When including this file in the assembly program file, all I/O register 
                                 ;* names and I/O register bit names appearing in the data book can be used.
                                 ;* In addition, the six registers forming the three data pointers X, Y and 
                                 ;* Z have been assigned names XL - ZH. Highest RAM address for Internal 
                                 ;* SRAM is also defined 
                                 ;* 
                                 ;* The Register names are represented by their hexadecimal address.
                                 ;* 
                                 ;* The Register Bit names are represented by their bit number (0-7).
                                 ;* 
                                 ;* Please observe the difference in using the bit names with instructions
                                 ;* such as "sbr"/"cbr" (set/clear bit in register) and "sbrs"/"sbrc"
                                 ;* (skip if bit in register set/cleared). The following example illustrates
                                 ;* this:
                                 ;* 
                                 ;* in    r16,PORTB             ;read PORTB latch
                                 ;* sbr   r16,(1<<PB6)+(1<<PB5) ;set PB6 and PB5 (use masks, not bit#)
                                 ;* out   PORTB,r16             ;output to PORTB
                                 ;* 
                                 ;* in    r16,TIFR              ;read the Timer Interrupt Flag Register
                                 ;* sbrc  r16,TOV0              ;test the overflow flag (use bit#)
                                 ;* rjmp  TOV0_is_set           ;jump if set
                                 ;* ...                         ;otherwise do something else
                                 ;*************************************************************************
                                 
                                 #ifndef _TN45DEF_INC_
                                 #define _TN45DEF_INC_
                                 
                                 
                                 #pragma partinc 0
                                 
                                 ; ***** SPECIFY DEVICE ***************************************************
                                 .device ATtiny45
                                 #pragma AVRPART ADMIN PART_NAME ATtiny45
                                 .equ	SIGNATURE_000	= 0x1e
                                 .equ	SIGNATURE_001	= 0x92
                                 .equ	SIGNATURE_002	= 0x06
                                 
                                 #pragma AVRPART CORE CORE_VERSION V2
                                 #pragma AVRPART CORE NEW_INSTRUCTIONS lpm rd,z+
                                 
                                 
                                 ; ***** I/O REGISTER DEFINITIONS *****************************************
                                 ; NOTE:
                                 ; Definitions marked "MEMORY MAPPED"are extended I/O ports
                                 ; and cannot be used with IN/OUT instructions
                                 .equ	SREG	= 0x3f
                                 .equ	SPL	= 0x3d
                                 .equ	SPH	= 0x3e
                                 .equ	GIMSK	= 0x3b
                                 .equ	GIFR	= 0x3a
                                 .equ	TIMSK	= 0x39
                                 .equ	TIFR	= 0x38
                                 .equ	SPMCSR	= 0x37
                                 .equ	MCUCR	= 0x35
                                 .equ	MCUSR	= 0x34
                                 .equ	TCCR0B	= 0x33
                                 .equ	TCNT0	= 0x32
                                 .equ	OSCCAL	= 0x31
                                 .equ	TCCR1	= 0x30
                                 .equ	TCNT1	= 0x2f
                                 .equ	OCR1A	= 0x2e
                                 .equ	OCR1C	= 0x2d
                                 .equ	GTCCR	= 0x2c
                                 .equ	OCR1B	= 0x2b
                                 .equ	TCCR0A	= 0x2a
                                 .equ	OCR0A	= 0x29
                                 .equ	OCR0B	= 0x28
                                 .equ	PLLCSR	= 0x27
                                 .equ	CLKPR	= 0x26
                                 .equ	DT1A	= 0x25
                                 .equ	DT1B	= 0x24
                                 .equ	DTPS	= 0x23
                                 .equ	DWDR	= 0x22
                                 .equ	WDTCR	= 0x21
                                 .equ	PRR	= 0x20
                                 .equ	EEARH	= 0x1f
                                 .equ	EEARL	= 0x1e
                                 .equ	EEDR	= 0x1d
                                 .equ	EECR	= 0x1c
                                 .equ	PORTB	= 0x18
                                 .equ	DDRB	= 0x17
                                 .equ	PINB	= 0x16
                                 .equ	PCMSK	= 0x15
                                 .equ	DIDR0	= 0x14
                                 .equ	GPIOR2	= 0x13
                                 .equ	GPIOR1	= 0x12
                                 .equ	GPIOR0	= 0x11
                                 .equ	USIBR	= 0x10
                                 .equ	USIDR	= 0x0f
                                 .equ	USISR	= 0x0e
                                 .equ	USICR	= 0x0d
                                 .equ	ACSR	= 0x08
                                 .equ	ADMUX	= 0x07
                                 .equ	ADCSRA	= 0x06
                                 .equ	ADCH	= 0x05
                                 .equ	ADCL	= 0x04
                                 .equ	ADCSRB	= 0x03
                                 
                                 
                                 ; ***** BIT DEFINITIONS **************************************************
                                 
                                 ; ***** PORTB ************************
                                 ; PORTB - Data Register, Port B
                                 .equ	PORTB0	= 0	; 
                                 .equ	PB0	= 0	; For compatibility
                                 .equ	PORTB1	= 1	; 
                                 .equ	PB1	= 1	; For compatibility
                                 .equ	PORTB2	= 2	; 
                                 .equ	PB2	= 2	; For compatibility
                                 .equ	PORTB3	= 3	; 
                                 .equ	PB3	= 3	; For compatibility
                                 .equ	PORTB4	= 4	; 
                                 .equ	PB4	= 4	; For compatibility
                                 .equ	PORTB5	= 5	; 
                                 .equ	PB5	= 5	; For compatibility
                                 
                                 ; DDRB - Data Direction Register, Port B
                                 .equ	DDB0	= 0	; 
                                 .equ	DDB1	= 1	; 
                                 .equ	DDB2	= 2	; 
                                 .equ	DDB3	= 3	; 
                                 .equ	DDB4	= 4	; 
                                 .equ	DDB5	= 5	; 
                                 
                                 ; PINB - Input Pins, Port B
                                 .equ	PINB0	= 0	; 
                                 .equ	PINB1	= 1	; 
                                 .equ	PINB2	= 2	; 
                                 .equ	PINB3	= 3	; 
                                 .equ	PINB4	= 4	; 
                                 .equ	PINB5	= 5	; 
                                 
                                 
                                 ; ***** ANALOG_COMPARATOR ************
                                 ; ADCSRB - ADC Control and Status Register B
                                 .equ	ACME	= 6	; Analog Comparator Multiplexer Enable
                                 
                                 ; ACSR - Analog Comparator Control And Status Register
                                 .equ	ACIS0	= 0	; Analog Comparator Interrupt Mode Select bit 0
                                 .equ	ACIS1	= 1	; Analog Comparator Interrupt Mode Select bit 1
                                 .equ	ACIE	= 3	; Analog Comparator Interrupt Enable
                                 .equ	ACI	= 4	; Analog Comparator Interrupt Flag
                                 .equ	ACO	= 5	; Analog Compare Output
                                 .equ	ACBG	= 6	; Analog Comparator Bandgap Select
                                 .equ	AINBG	= ACBG	; For compatibility
                                 .equ	ACD	= 7	; Analog Comparator Disable
                                 
                                 ; DIDR0 - 
                                 .equ	AIN0D	= 0	; AIN0 Digital Input Disable
                                 .equ	AIN1D	= 1	; AIN1 Digital Input Disable
                                 
                                 
                                 ; ***** AD_CONVERTER *****************
                                 ; ADMUX - The ADC multiplexer Selection Register
                                 .equ	MUX0	= 0	; Analog Channel and Gain Selection Bits
                                 .equ	MUX1	= 1	; Analog Channel and Gain Selection Bits
                                 .equ	MUX2	= 2	; Analog Channel and Gain Selection Bits
                                 .equ	MUX3	= 3	; Analog Channel and Gain Selection Bits
                                 .equ	REFS2	= 4	; Reference Selection Bit 2
                                 .equ	ADLAR	= 5	; Left Adjust Result
                                 .equ	REFS0	= 6	; Reference Selection Bit 0
                                 .equ	REFS1	= 7	; Reference Selection Bit 1
                                 
                                 ; ADCSRA - The ADC Control and Status register
                                 .equ	ADPS0	= 0	; ADC  Prescaler Select Bits
                                 .equ	ADPS1	= 1	; ADC  Prescaler Select Bits
                                 .equ	ADPS2	= 2	; ADC  Prescaler Select Bits
                                 .equ	ADIE	= 3	; ADC Interrupt Enable
                                 .equ	ADIF	= 4	; ADC Interrupt Flag
                                 .equ	ADATE	= 5	; ADC Auto Trigger Enable
                                 .equ	ADSC	= 6	; ADC Start Conversion
                                 .equ	ADEN	= 7	; ADC Enable
                                 
                                 ; ADCH - ADC Data Register High Byte
                                 .equ	ADCH0	= 0	; ADC Data Register High Byte Bit 0
                                 .equ	ADCH1	= 1	; ADC Data Register High Byte Bit 1
                                 .equ	ADCH2	= 2	; ADC Data Register High Byte Bit 2
                                 .equ	ADCH3	= 3	; ADC Data Register High Byte Bit 3
                                 .equ	ADCH4	= 4	; ADC Data Register High Byte Bit 4
                                 .equ	ADCH5	= 5	; ADC Data Register High Byte Bit 5
                                 .equ	ADCH6	= 6	; ADC Data Register High Byte Bit 6
                                 .equ	ADCH7	= 7	; ADC Data Register High Byte Bit 7
                                 
                                 ; ADCL - ADC Data Register Low Byte
                                 .equ	ADCL0	= 0	; ADC Data Register Low Byte Bit 0
                                 .equ	ADCL1	= 1	; ADC Data Register Low Byte Bit 1
                                 .equ	ADCL2	= 2	; ADC Data Register Low Byte Bit 2
                                 .equ	ADCL3	= 3	; ADC Data Register Low Byte Bit 3
                                 .equ	ADCL4	= 4	; ADC Data Register Low Byte Bit 4
                                 .equ	ADCL5	= 5	; ADC Data Register Low Byte Bit 5
                                 .equ	ADCL6	= 6	; ADC Data Register Low Byte Bit 6
                                 .equ	ADCL7	= 7	; ADC Data Register Low Byte Bit 7
                                 
                                 ; ADCSRB - ADC Control and Status Register B
                                 .equ	ADTS0	= 0	; ADC Auto Trigger Source 0
                                 .equ	ADTS1	= 1	; ADC Auto Trigger Source 1
                                 .equ	ADTS2	= 2	; ADC Auto Trigger Source 2
                                 .equ	IPR	= 5	; Input Polarity Mode
                                 .equ	BIN	= 7	; Bipolar Input Mode
                                 
                                 ; DIDR0 - Digital Input Disable Register 0
                                 .equ	ADC1D	= 2	; ADC1 Digital input Disable
                                 .equ	ADC3D	= 3	; ADC3 Digital input Disable
                                 .equ	ADC2D	= 4	; ADC2 Digital input Disable
                                 .equ	ADC0D	= 5	; ADC0 Digital input Disable
                                 
                                 
                                 ; ***** USI **************************
                                 ; USIBR - USI Buffer Register
                                 .equ	USIBR0	= 0	; USI Buffer Register bit 0
                                 .equ	USIBR1	= 1	; USI Buffer Register bit 1
                                 .equ	USIBR2	= 2	; USI Buffer Register bit 2
                                 .equ	USIBR3	= 3	; USI Buffer Register bit 3
                                 .equ	USIBR4	= 4	; USI Buffer Register bit 4
                                 .equ	USIBR5	= 5	; USI Buffer Register bit 5
                                 .equ	USIBR6	= 6	; USI Buffer Register bit 6
                                 .equ	USIBR7	= 7	; USI Buffer Register bit 7
                                 
                                 ; USIDR - USI Data Register
                                 .equ	USIDR0	= 0	; USI Data Register bit 0
                                 .equ	USIDR1	= 1	; USI Data Register bit 1
                                 .equ	USIDR2	= 2	; USI Data Register bit 2
                                 .equ	USIDR3	= 3	; USI Data Register bit 3
                                 .equ	USIDR4	= 4	; USI Data Register bit 4
                                 .equ	USIDR5	= 5	; USI Data Register bit 5
                                 .equ	USIDR6	= 6	; USI Data Register bit 6
                                 .equ	USIDR7	= 7	; USI Data Register bit 7
                                 
                                 ; USISR - USI Status Register
                                 .equ	USICNT0	= 0	; USI Counter Value Bit 0
                                 .equ	USICNT1	= 1	; USI Counter Value Bit 1
                                 .equ	USICNT2	= 2	; USI Counter Value Bit 2
                                 .equ	USICNT3	= 3	; USI Counter Value Bit 3
                                 .equ	USIDC	= 4	; Data Output Collision
                                 .equ	USIPF	= 5	; Stop Condition Flag
                                 .equ	USIOIF	= 6	; Counter Overflow Interrupt Flag
                                 .equ	USISIF	= 7	; Start Condition Interrupt Flag
                                 
                                 ; USICR - USI Control Register
                                 .equ	USITC	= 0	; Toggle Clock Port Pin
                                 .equ	USICLK	= 1	; Clock Strobe
                                 .equ	USICS0	= 2	; USI Clock Source Select Bit 0
                                 .equ	USICS1	= 3	; USI Clock Source Select Bit 1
                                 .equ	USIWM0	= 4	; USI Wire Mode Bit 0
                                 .equ	USIWM1	= 5	; USI Wire Mode Bit 1
                                 .equ	USIOIE	= 6	; Counter Overflow Interrupt Enable
                                 .equ	USISIE	= 7	; Start Condition Interrupt Enable
                                 
                                 
                                 ; ***** EXTERNAL_INTERRUPT ***********
                                 ; MCUCR - MCU Control Register
                                 .equ	ISC00	= 0	; Interrupt Sense Control 0 Bit 0
                                 .equ	ISC01	= 1	; Interrupt Sense Control 0 Bit 1
                                 
                                 ; GIMSK - General Interrupt Mask Register
                                 .equ	GICR	= GIMSK	; For compatibility
                                 .equ	PCIE	= 5	; Pin Change Interrupt Enable
                                 .equ	INT0	= 6	; External Interrupt Request 0 Enable
                                 
                                 ; GIFR - General Interrupt Flag register
                                 .equ	PCIF	= 5	; Pin Change Interrupt Flag
                                 .equ	INTF0	= 6	; External Interrupt Flag 0
                                 
                                 ; PCMSK - Pin Change Enable Mask
                                 .equ	PCINT0	= 0	; Pin Change Enable Mask Bit 0
                                 .equ	PCINT1	= 1	; Pin Change Enable Mask Bit 1
                                 .equ	PCINT2	= 2	; Pin Change Enable Mask Bit 2
                                 .equ	PCINT3	= 3	; Pin Change Enable Mask Bit 3
                                 .equ	PCINT4	= 4	; Pin Change Enable Mask Bit 4
                                 .equ	PCINT5	= 5	; Pin Change Enable Mask Bit 5
                                 
                                 
                                 ; ***** EEPROM ***********************
                                 ; EEARL - EEPROM Address Register Low Byte
                                 .equ	EEAR0	= 0	; EEPROM Read/Write Access Bit 0
                                 .equ	EEAR1	= 1	; EEPROM Read/Write Access Bit 1
                                 .equ	EEAR2	= 2	; EEPROM Read/Write Access Bit 2
                                 .equ	EEAR3	= 3	; EEPROM Read/Write Access Bit 3
                                 .equ	EEAR4	= 4	; EEPROM Read/Write Access Bit 4
                                 .equ	EEAR5	= 5	; EEPROM Read/Write Access Bit 5
                                 .equ	EEAR6	= 6	; EEPROM Read/Write Access Bit 6
                                 .equ	EEAR7	= 7	; EEPROM Read/Write Access Bit 7
                                 
                                 ; EEARH - EEPROM Address Register High Byte
                                 .equ	EEAR8	= 0	; EEPROM Read/Write Access Bit 0
                                 
                                 ; EEDR - EEPROM Data Register
                                 .equ	EEDR0	= 0	; EEPROM Data Register bit 0
                                 .equ	EEDR1	= 1	; EEPROM Data Register bit 1
                                 .equ	EEDR2	= 2	; EEPROM Data Register bit 2
                                 .equ	EEDR3	= 3	; EEPROM Data Register bit 3
                                 .equ	EEDR4	= 4	; EEPROM Data Register bit 4
                                 .equ	EEDR5	= 5	; EEPROM Data Register bit 5
                                 .equ	EEDR6	= 6	; EEPROM Data Register bit 6
                                 .equ	EEDR7	= 7	; EEPROM Data Register bit 7
                                 
                                 ; EECR - EEPROM Control Register
                                 .equ	EERE	= 0	; EEPROM Read Enable
                                 .equ	EEPE	= 1	; EEPROM Write Enable
                                 .equ	EEMPE	= 2	; EEPROM Master Write Enable
                                 .equ	EERIE	= 3	; EEPROM Ready Interrupt Enable
                                 .equ	EEPM0	= 4	; EEPROM Programming Mode Bit 0
                                 .equ	EEPM1	= 5	; EEPROM Programming Mode Bit 1
                                 
                                 
                                 ; ***** WATCHDOG *********************
                                 ; WDTCR - Watchdog Timer Control Register
                                 .equ	WDTCSR	= WDTCR	; For compatibility
                                 .equ	WDP0	= 0	; Watch Dog Timer Prescaler bit 0
                                 .equ	WDP1	= 1	; Watch Dog Timer Prescaler bit 1
                                 .equ	WDP2	= 2	; Watch Dog Timer Prescaler bit 2
                                 .equ	WDE	= 3	; Watch Dog Enable
                                 .equ	WDCE	= 4	; Watchdog Change Enable
                                 .equ	WDTOE	= WDCE	; For compatibility
                                 .equ	WDP3	= 5	; Watchdog Timer Prescaler Bit 3
                                 .equ	WDIE	= 6	; Watchdog Timeout Interrupt Enable
                                 .equ	WDIF	= 7	; Watchdog Timeout Interrupt Flag
                                 
                                 
                                 ; ***** TIMER_COUNTER_0 **************
                                 ; TIMSK - Timer/Counter Interrupt Mask Register
                                 .equ	TOIE0	= 1	; Timer/Counter0 Overflow Interrupt Enable
                                 .equ	OCIE0B	= 3	; Timer/Counter0 Output Compare Match B Interrupt Enable
                                 .equ	OCIE0A	= 4	; Timer/Counter0 Output Compare Match A Interrupt Enable
                                 
                                 ; TIFR - Timer/Counter0 Interrupt Flag register
                                 .equ	TOV0	= 1	; Timer/Counter0 Overflow Flag
                                 .equ	OCF0B	= 3	; Timer/Counter0 Output Compare Flag 0B
                                 .equ	OCF0A	= 4	; Timer/Counter0 Output Compare Flag 0A
                                 
                                 ; TCCR0A - Timer/Counter  Control Register A
                                 .equ	WGM00	= 0	; Waveform Generation Mode
                                 .equ	WGM01	= 1	; Waveform Generation Mode
                                 .equ	COM0B0	= 4	; Compare Output Mode, Fast PWm
                                 .equ	COM0B1	= 5	; Compare Output Mode, Fast PWm
                                 .equ	COM0A0	= 6	; Compare Output Mode, Phase Correct PWM Mode
                                 .equ	COM0A1	= 7	; Compare Output Mode, Phase Correct PWM Mode
                                 
                                 ; TCCR0B - Timer/Counter Control Register B
                                 .equ	CS00	= 0	; Clock Select
                                 .equ	CS01	= 1	; Clock Select
                                 .equ	CS02	= 2	; Clock Select
                                 .equ	WGM02	= 3	; 
                                 .equ	FOC0B	= 6	; Force Output Compare B
                                 .equ	FOC0A	= 7	; Force Output Compare A
                                 
                                 ; TCNT0 - Timer/Counter0
                                 .equ	TCNT0_0	= 0	; 
                                 .equ	TCNT0_1	= 1	; 
                                 .equ	TCNT0_2	= 2	; 
                                 .equ	TCNT0_3	= 3	; 
                                 .equ	TCNT0_4	= 4	; 
                                 .equ	TCNT0_5	= 5	; 
                                 .equ	TCNT0_6	= 6	; 
                                 .equ	TCNT0_7	= 7	; 
                                 
                                 ; OCR0A - Timer/Counter0 Output Compare Register
                                 .equ	OCR0_0	= 0	; 
                                 .equ	OCR0_1	= 1	; 
                                 .equ	OCR0_2	= 2	; 
                                 .equ	OCR0_3	= 3	; 
                                 .equ	OCR0_4	= 4	; 
                                 .equ	OCR0_5	= 5	; 
                                 .equ	OCR0_6	= 6	; 
                                 .equ	OCR0_7	= 7	; 
                                 
                                 ; OCR0B - Timer/Counter0 Output Compare Register
                                 ;.equ	OCR0_0	= 0	; 
                                 ;.equ	OCR0_1	= 1	; 
                                 ;.equ	OCR0_2	= 2	; 
                                 ;.equ	OCR0_3	= 3	; 
                                 ;.equ	OCR0_4	= 4	; 
                                 ;.equ	OCR0_5	= 5	; 
                                 ;.equ	OCR0_6	= 6	; 
                                 ;.equ	OCR0_7	= 7	; 
                                 
                                 ; GTCCR - General Timer/Counter Control Register
                                 .equ	PSR0	= 0	; Prescaler Reset Timer/Counter1 and Timer/Counter0
                                 .equ	TSM	= 7	; Timer/Counter Synchronization Mode
                                 
                                 
                                 ; ***** TIMER_COUNTER_1 **************
                                 ; TCCR1 - Timer/Counter Control Register
                                 .equ	CS10	= 0	; Clock Select Bits
                                 .equ	CS11	= 1	; Clock Select Bits
                                 .equ	CS12	= 2	; Clock Select Bits
                                 .equ	CS13	= 3	; Clock Select Bits
                                 .equ	COM1A0	= 4	; Compare Output Mode, Bit 1
                                 .equ	COM1A1	= 5	; Compare Output Mode, Bit 0
                                 .equ	PWM1A	= 6	; Pulse Width Modulator Enable
                                 .equ	CTC1	= 7	; Clear Timer/Counter on Compare Match
                                 
                                 ; TCNT1 - Timer/Counter Register
                                 .equ	TCNT1_0	= 0	; Timer/Counter Register Bit 0
                                 .equ	TCNT1_1	= 1	; Timer/Counter Register Bit 1
                                 .equ	TCNT1_2	= 2	; Timer/Counter Register Bit 2
                                 .equ	TCNT1_3	= 3	; Timer/Counter Register Bit 3
                                 .equ	TCNT1_4	= 4	; Timer/Counter Register Bit 4
                                 .equ	TCNT1_5	= 5	; Timer/Counter Register Bit 5
                                 .equ	TCNT1_6	= 6	; Timer/Counter Register Bit 6
                                 .equ	TCNT1_7	= 7	; Timer/Counter Register Bit 7
                                 
                                 ; OCR1A - Output Compare Register
                                 .equ	OCR1A0	= 0	; Output Compare Register A Bit 0
                                 .equ	OCR1A1	= 1	; Output Compare Register A Bit 1
                                 .equ	OCR1A2	= 2	; Output Compare Register A Bit 2
                                 .equ	OCR1A3	= 3	; Output Compare Register A Bit 3
                                 .equ	OCR1A4	= 4	; Output Compare Register A Bit 4
                                 .equ	OCR1A5	= 5	; Output Compare Register A Bit 5
                                 .equ	OCR1A6	= 6	; Output Compare Register A Bit 6
                                 .equ	OCR1A7	= 7	; Output Compare Register A Bit 7
                                 
                                 ; OCR1B - Output Compare Register
                                 .equ	OCR1B0	= 0	; Output Compare Register B Bit 0
                                 .equ	OCR1B1	= 1	; Output Compare Register B Bit 1
                                 .equ	OCR1B2	= 2	; Output Compare Register B Bit 2
                                 .equ	OCR1B3	= 3	; Output Compare Register B Bit 3
                                 .equ	OCR1B4	= 4	; Output Compare Register B Bit 4
                                 .equ	OCR1B5	= 5	; Output Compare Register B Bit 5
                                 .equ	OCR1B6	= 6	; Output Compare Register B Bit 6
                                 .equ	OCR1B7	= 7	; Output Compare Register B Bit 7
                                 
                                 ; OCR1C - Output compare register
                                 .equ	OCR1C0	= 0	; 
                                 .equ	OCR1C1	= 1	; 
                                 .equ	OCR1C2	= 2	; 
                                 .equ	OCR1C3	= 3	; 
                                 .equ	OCR1C4	= 4	; 
                                 .equ	OCR1C5	= 5	; 
                                 .equ	OCR1C6	= 6	; 
                                 .equ	OCR1C7	= 7	; 
                                 
                                 ; TIMSK - Timer/Counter Interrupt Mask Register
                                 .equ	TOIE1	= 2	; Timer/Counter1 Overflow Interrupt Enable
                                 .equ	OCIE1B	= 5	; OCIE1A: Timer/Counter1 Output Compare B Interrupt Enable
                                 .equ	OCIE1A	= 6	; OCIE1A: Timer/Counter1 Output Compare Interrupt Enable
                                 
                                 ; TIFR - Timer/Counter Interrupt Flag Register
                                 .equ	TOV1	= 2	; Timer/Counter1 Overflow Flag
                                 .equ	OCF1B	= 5	; Timer/Counter1 Output Compare Flag 1B
                                 .equ	OCF1A	= 6	; Timer/Counter1 Output Compare Flag 1A
                                 
                                 ; GTCCR - Timer counter control register
                                 .equ	PSR1	= 1	; Prescaler Reset Timer/Counter1
                                 .equ	FOC1A	= 2	; Force Output Compare 1A
                                 .equ	FOC1B	= 3	; Force Output Compare Match 1B
                                 .equ	COM1B0	= 4	; Comparator B Output Mode
                                 .equ	COM1B1	= 5	; Comparator B Output Mode
                                 .equ	PWM1B	= 6	; Pulse Width Modulator B Enable
                                 
                                 ; DTPS - Dead time prescaler register
                                 .equ	DTPS0	= 0	; 
                                 .equ	DTPS1	= 1	; 
                                 
                                 ; DT1A - Dead time value register
                                 .equ	DTVL0	= 0	; 
                                 .equ	DTVL1	= 1	; 
                                 .equ	DTVL2	= 2	; 
                                 .equ	DTVL3	= 3	; 
                                 .equ	DTVH0	= 4	; 
                                 .equ	DTVH1	= 5	; 
                                 .equ	DTVH2	= 6	; 
                                 .equ	DTVH3	= 7	; 
                                 
                                 ; DT1B - Dead time value B
                                 ;.equ	DTVL0	= 0	; 
                                 ;.equ	DTVL1	= 1	; 
                                 ;.equ	DTVL2	= 2	; 
                                 ;.equ	DTVL3	= 3	; 
                                 ;.equ	DTVH0	= 4	; 
                                 ;.equ	DTVH1	= 5	; 
                                 ;.equ	DTVH2	= 6	; 
                                 ;.equ	DTVH3	= 7	; 
                                 
                                 
                                 ; ***** CPU **************************
                                 ; SREG - Status Register
                                 .equ	SREG_C	= 0	; Carry Flag
                                 .equ	SREG_Z	= 1	; Zero Flag
                                 .equ	SREG_N	= 2	; Negative Flag
                                 .equ	SREG_V	= 3	; Two's Complement Overflow Flag
                                 .equ	SREG_S	= 4	; Sign Bit
                                 .equ	SREG_H	= 5	; Half Carry Flag
                                 .equ	SREG_T	= 6	; Bit Copy Storage
                                 .equ	SREG_I	= 7	; Global Interrupt Enable
                                 
                                 ; MCUCR - MCU Control Register
                                 ;.equ	ISC00	= 0	; Interrupt Sense Control 0 bit 0
                                 ;.equ	ISC01	= 1	; Interrupt Sense Control 0 bit 1
                                 .equ	BODSE	= 2	; BOD Sleep Enable
                                 .equ	SM0	= 3	; Sleep Mode Select Bit 0
                                 .equ	SM1	= 4	; Sleep Mode Select Bit 1
                                 .equ	SE	= 5	; Sleep Enable
                                 .equ	PUD	= 6	; Pull-up Disable
                                 .equ	BODS	= 7	; BOD Sleep
                                 
                                 ; MCUSR - MCU Status register
                                 .equ	PORF	= 0	; Power-On Reset Flag
                                 .equ	EXTRF	= 1	; External Reset Flag
                                 .equ	BORF	= 2	; Brown-out Reset Flag
                                 .equ	WDRF	= 3	; Watchdog Reset Flag
                                 
                                 ; PRR - Power Reduction Register
                                 .equ	PRADC	= 0	; Power Reduction ADC
                                 .equ	PRUSI	= 1	; Power Reduction USI
                                 .equ	PRTIM0	= 2	; Power Reduction Timer/Counter0
                                 .equ	PRTIM1	= 3	; Power Reduction Timer/Counter1
                                 
                                 ; OSCCAL - Oscillator Calibration Register
                                 .equ	CAL0	= 0	; Oscillatro Calibration Value Bit 0
                                 .equ	CAL1	= 1	; Oscillatro Calibration Value Bit 1
                                 .equ	CAL2	= 2	; Oscillatro Calibration Value Bit 2
                                 .equ	CAL3	= 3	; Oscillatro Calibration Value Bit 3
                                 .equ	CAL4	= 4	; Oscillatro Calibration Value Bit 4
                                 .equ	CAL5	= 5	; Oscillatro Calibration Value Bit 5
                                 .equ	CAL6	= 6	; Oscillatro Calibration Value Bit 6
                                 .equ	CAL7	= 7	; Oscillatro Calibration Value Bit 7
                                 
                                 ; PLLCSR - PLL Control and status register
                                 .equ	PLOCK	= 0	; PLL Lock detector
                                 .equ	PLLE	= 1	; PLL Enable
                                 .equ	PCKE	= 2	; PCK Enable
                                 .equ	LSM	= 7	; Low speed mode
                                 
                                 ; CLKPR - Clock Prescale Register
                                 .equ	CLKPS0	= 0	; Clock Prescaler Select Bit 0
                                 .equ	CLKPS1	= 1	; Clock Prescaler Select Bit 1
                                 .equ	CLKPS2	= 2	; Clock Prescaler Select Bit 2
                                 .equ	CLKPS3	= 3	; Clock Prescaler Select Bit 3
                                 .equ	CLKPCE	= 7	; Clock Prescaler Change Enable
                                 
                                 ; DWDR - debugWire data register
                                 .equ	DWDR0	= 0	; 
                                 .equ	DWDR1	= 1	; 
                                 .equ	DWDR2	= 2	; 
                                 .equ	DWDR3	= 3	; 
                                 .equ	DWDR4	= 4	; 
                                 .equ	DWDR5	= 5	; 
                                 .equ	DWDR6	= 6	; 
                                 .equ	DWDR7	= 7	; 
                                 
                                 ; GPIOR2 - General Purpose IO register 2
                                 .equ	GPIOR20	= 0	; 
                                 .equ	GPIOR21	= 1	; 
                                 .equ	GPIOR22	= 2	; 
                                 .equ	GPIOR23	= 3	; 
                                 .equ	GPIOR24	= 4	; 
                                 .equ	GPIOR25	= 5	; 
                                 .equ	GPIOR26	= 6	; 
                                 .equ	GPIOR27	= 7	; 
                                 
                                 ; GPIOR1 - General Purpose register 1
                                 .equ	GPIOR10	= 0	; 
                                 .equ	GPIOR11	= 1	; 
                                 .equ	GPIOR12	= 2	; 
                                 .equ	GPIOR13	= 3	; 
                                 .equ	GPIOR14	= 4	; 
                                 .equ	GPIOR15	= 5	; 
                                 .equ	GPIOR16	= 6	; 
                                 .equ	GPIOR17	= 7	; 
                                 
                                 ; GPIOR0 - General purpose register 0
                                 .equ	GPIOR00	= 0	; 
                                 .equ	GPIOR01	= 1	; 
                                 .equ	GPIOR02	= 2	; 
                                 .equ	GPIOR03	= 3	; 
                                 .equ	GPIOR04	= 4	; 
                                 .equ	GPIOR05	= 5	; 
                                 .equ	GPIOR06	= 6	; 
                                 .equ	GPIOR07	= 7	; 
                                 
                                 
                                 ; ***** BOOT_LOAD ********************
                                 ; SPMCSR - Store Program Memory Control Register
                                 .equ	SPMEN	= 0	; Store Program Memory Enable
                                 .equ	PGERS	= 1	; Page Erase
                                 .equ	PGWRT	= 2	; Page Write
                                 .equ	RFLB	= 3	; Read fuse and lock bits
                                 .equ	CTPB	= 4	; Clear temporary page buffer
                                 
                                 
                                 
                                 ; ***** LOCKSBITS ********************************************************
                                 .equ	LB1	= 0	; Lockbit
                                 .equ	LB2	= 1	; Lockbit
                                 
                                 
                                 ; ***** FUSES ************************************************************
                                 ; LOW fuse bits
                                 .equ	CKSEL0	= 0	; Select Clock source
                                 .equ	CKSEL1	= 1	; Select Clock source
                                 .equ	CKSEL2	= 2	; Select Clock source
                                 .equ	CKSEL3	= 3	; Select Clock source
                                 .equ	SUT0	= 4	; Select start-up time
                                 .equ	SUT1	= 5	; Select start-up time
                                 .equ	CKOUT	= 6	; Clock Output Enable
                                 .equ	CKDIV8	= 7	; Divide clock by 8
                                 
                                 ; HIGH fuse bits
                                 .equ	BODLEVEL0	= 0	; Brown-out Detector trigger level
                                 .equ	BODLEVEL1	= 1	; Brown-out Detector trigger level
                                 .equ	BODLEVEL2	= 2	; Brown-out Detector trigger level
                                 .equ	EESAVE	= 3	; EEPROM memory is preserved through the Chip Erase
                                 .equ	WDTON	= 4	; Watchdog Timer always on
                                 .equ	SPIEN	= 5	; Enable Serial Program and Data Downloading
                                 .equ	DWEN	= 6	; DebugWIRE Enable
                                 .equ	RSTDISBL	= 7	; External Reset disable
                                 
                                 ; EXTENDED fuse bits
                                 .equ	SELFPRGEN	= 0	; Self-Programming Enable
                                 
                                 
                                 
                                 ; ***** CPU REGISTER DEFINITIONS *****************************************
                                 .def	XH	= r27
                                 .def	XL	= r26
                                 .def	YH	= r29
                                 .def	YL	= r28
                                 .def	ZH	= r31
                                 .def	ZL	= r30
                                 
                                 
                                 
                                 ; ***** DATA MEMORY DECLARATIONS *****************************************
                                 .equ	FLASHEND	= 0x07ff	; Note: Word address
                                 .equ	IOEND	= 0x003f
                                 .equ	SRAM_START	= 0x0060
                                 .equ	SRAM_SIZE	= 256
                                 .equ	RAMEND	= 0x015f
                                 .equ	XRAMEND	= 0x0000
                                 .equ	E2END	= 0x00ff
                                 .equ	EEPROMEND	= 0x00ff
                                 .equ	EEADRBITS	= 8
                                 #pragma AVRPART MEMORY PROG_FLASH 4096
                                 #pragma AVRPART MEMORY EEPROM 256
                                 #pragma AVRPART MEMORY INT_SRAM SIZE 256
                                 #pragma AVRPART MEMORY INT_SRAM START_ADDR 0x60
                                 
                                 
                                 
                                 ; ***** BOOTLOADER DECLARATIONS ******************************************
                                 .equ	NRWW_START_ADDR	= 0x0
                                 .equ	NRWW_STOP_ADDR	= 0x7ff
                                 .equ	RWW_START_ADDR	= 0x0
                                 .equ	RWW_STOP_ADDR	= 0x0
                                 .equ	PAGESIZE	= 32
                                 
                                 
                                 
                                 ; ***** INTERRUPT VECTORS ************************************************
                                 .equ	INT0addr	= 0x0001	; External Interrupt 0
                                 .equ	PCI0addr	= 0x0002	; Pin change Interrupt Request 0
                                 .equ	OC1Aaddr	= 0x0003	; Timer/Counter1 Compare Match 1A
                                 .equ	OVF1addr	= 0x0004	; Timer/Counter1 Overflow
                                 .equ	OVF0addr	= 0x0005	; Timer/Counter0 Overflow
                                 .equ	ERDYaddr	= 0x0006	; EEPROM Ready
                                 .equ	ACIaddr	= 0x0007	; Analog comparator
                                 .equ	ADCCaddr	= 0x0008	; ADC Conversion ready
                                 .equ	OC1Baddr	= 0x0009	; Timer/Counter1 Compare Match B
                                 .equ	OC0Aaddr	= 0x000a	; Timer/Counter0 Compare Match A
                                 .equ	OC0Baddr	= 0x000b	; Timer/Counter0 Compare Match B
                                 .equ	WDTaddr	= 0x000c	; Watchdog Time-out
                                 .equ	USI_STARTaddr	= 0x000d	; USI START
                                 .equ	USI_OVFaddr	= 0x000e	; USI Overflow
                                 
                                 .equ	INT_VECTORS_SIZE	= 15	; size in words
                                 
                                 #endif  /* _TN45DEF_INC_ */
                                 
                                 ; ***** END OF FILE ******************************************************
                                 
                                 ; SHA-512.asm
                                 ;
                                 ; Created: 2020-07-09 오후 12:26:55
                                 ; Author : 김영범
                                 ;
                                 
                                 
                                 ; Replace with your application code Copyright 짤 L. Van Oldeneel tot Oldenzeel, S. Kerckhof, 2012.
                                 ; e-mail:  <loic.vanoldeneel@uclouvain.be>, <stephanie.kerckhof@uclouvain.be>.
                                 ;
                                 ; This program is a free software: you can redistribute it
                                 ; and/or modify it under the terms of the GNU General Public
                                 ; License as published by the Free Software Foundation.
                                 ;
                                 ; It is distributed without any warranty of correctness nor
                                 ; fintess for any particular purpose. See the GNU General
                                 ; Public License for more details.
                                 ;
                                 ; <http://www.gnu.org/licenses/>.
                                 ;
                                 ; Description: Main test program for hash functions
                                 ; Version 1 - March 2012.
                                 
                                 .include "tn45def.inc"
                                 
                                 ;***** Created: 2011-02-09 12:04 ******* Source: ATtiny45.xml ************
                                 ;*************************************************************************
                                 ;* A P P L I C A T I O N   N O T E   F O R   T H E   A V R   F A M I L Y
                                 ;* 
                                 ;* Number            : AVR000
                                 ;* File Name         : "tn45def.inc"
                                 ;* Title             : Register/Bit Definitions for the ATtiny45
                                 ;* Date              : 2011-02-09
                                 ;* Version           : 2.35
                                 ;* Support E-mail    : avr@atmel.com
                                 ;* Target MCU        : ATtiny45
                                 ;* 
                                 ;* DESCRIPTION
                                 ;* When including this file in the assembly program file, all I/O register 
                                 ;* names and I/O register bit names appearing in the data book can be used.
                                 ;* In addition, the six registers forming the three data pointers X, Y and 
                                 ;* Z have been assigned names XL - ZH. Highest RAM address for Internal 
                                 ;* SRAM is also defined 
                                 ;* 
                                 ;* The Register names are represented by their hexadecimal address.
                                 ;* 
                                 ;* The Register Bit names are represented by their bit number (0-7).
                                 ;* 
                                 ;* Please observe the difference in using the bit names with instructions
                                 ;* such as "sbr"/"cbr" (set/clear bit in register) and "sbrs"/"sbrc"
                                 ;* (skip if bit in register set/cleared). The following example illustrates
                                 ;* this:
                                 ;* 
                                 ;* in    r16,PORTB             ;read PORTB latch
                                 ;* sbr   r16,(1<<PB6)+(1<<PB5) ;set PB6 and PB5 (use masks, not bit#)
                                 ;* out   PORTB,r16             ;output to PORTB
                                 ;* 
                                 ;* in    r16,TIFR              ;read the Timer Interrupt Flag Register
                                 ;* sbrc  r16,TOV0              ;test the overflow flag (use bit#)
                                 ;* rjmp  TOV0_is_set           ;jump if set
                                 ;* ...                         ;otherwise do something else
                                 ;*************************************************************************
                                 
                                 #ifndef _TN45DEF_INC_
                                 #endif  /* _TN45DEF_INC_ */
                                 
                                 ; ***** END OF FILE ******************************************************
                                 
                                 #define blake ;TO_UPD specify which hash function will be included
                                 .equ msg_size = 1	;TO_UPD specify lenght of message to hash
                                 
                                 .ORG 0x0000
                                 ; global interrupt disable
000000 94f8                      	cli
                                 ; initialize stack
000001 e0f1                      	ldi		r31,HIGH(RAMEND)
000002 bffe                      	out		SPH,r31
000003 e5ff                      	ldi		r31,LOW(RAMEND)
000004 bffd                      	out		SPL,r31
                                 
                                 ; initialize trigger B1
000005 e003                        	ldi		r16, 0b11	; portB,1 = output (triggers)
000006 bb07                        	out		DDRB, r16
                                 
000007 c247                      	rjmp	main
                                 
                                 
                                 ;******************* INCLUDE FILES *******************************
                                 ; include hash function ;TO_UPD add a condition for the new hash function
                                 #ifdef shrimpton
                                 #elif DM_rijndael
                                 #elif blake
                                 	.include	"blake_256.asm"
                                 
                                  * blake_256.asm
                                  *
                                  *  Created: 2020-07-09 ?? 12:31:18
                                  *   Author: ???
                                  */ 
                                  ;
                                 ; Copyright ? I. von Maurich
                                 ; e-mail: <ingo.vonmaurich@rub.de>.
                                 ;
                                 ; This program is a free software: you can redistribute it
                                 ; and/or modify it under the terms of the GNU General Public
                                 ; License as published by the Free Software Foundation.
                                 ;
                                 ; It is distributed without any warranty of correctness nor
                                 ; fintess for any particular purpose. See the GNU General
                                 ; Public License for more details.
                                 ;
                                 ; <http://www.gnu.org/licenses/>.
                                 ;
                                 ; Description: Blake256 hash function.
                                 ; Version 1 - June 2012.
                                 ;
                                 ;
                                 ;   ----------------------------------------------------
                                 ;  |    User interface:                                 |
                                 ;  |----------------------------------------------------|
                                 ;  |(1) Data to hash must be in SRAM with the first byte|
                                 ;  |    at the location pointed by SRAM_DATA. The data  |
                                 ;  |    has to be updated before each update or final   |
                                 ;  |    call and the number of bytes needed in SRAM by  |
                                 ;  |    each update call is equal to DATA_NUM_BYTE.     |
                                 ;  |                                                    |
                                 ;  |    If final routine is called, r24 must contain    |
                                 ;  |    the number of bytes of data passed to the       |
                                 ;  |    function.                                       |
                                 ;  |----------------------------------------------------|
                                 ;  |(2) Call init, update or final routine              |
                                 ;  |----------------------------------------------------|
                                 ;  |(3) After each call, the intermediate (or final)    |
                                 ;  |    hash function state is at location pointed by   |
                                 ;  |    SRAM_STATE. Lenght of hash intermediate states  |
                                 ;  |    is given by STATE_NUM_BYTE constant.            |
                                 ;  |    Lenght of final hash value is given by          |
                                 ;  |    HASH_NUM_BYTE.                                  |
                                 ;   ----------------------------------------------------
                                 ;
                                 
                                 .include "tn45def.inc"
                                 
                                 ;***** Created: 2011-02-09 12:04 ******* Source: ATtiny45.xml ************
                                 ;*************************************************************************
                                 ;* A P P L I C A T I O N   N O T E   F O R   T H E   A V R   F A M I L Y
                                 ;* 
                                 ;* Number            : AVR000
                                 ;* File Name         : "tn45def.inc"
                                 ;* Title             : Register/Bit Definitions for the ATtiny45
                                 ;* Date              : 2011-02-09
                                 ;* Version           : 2.35
                                 ;* Support E-mail    : avr@atmel.com
                                 ;* Target MCU        : ATtiny45
                                 ;* 
                                 ;* DESCRIPTION
                                 ;* When including this file in the assembly program file, all I/O register 
                                 ;* names and I/O register bit names appearing in the data book can be used.
                                 ;* In addition, the six registers forming the three data pointers X, Y and 
                                 ;* Z have been assigned names XL - ZH. Highest RAM address for Internal 
                                 ;* SRAM is also defined 
                                 ;* 
                                 ;* The Register names are represented by their hexadecimal address.
                                 ;* 
                                 ;* The Register Bit names are represented by their bit number (0-7).
                                 ;* 
                                 ;* Please observe the difference in using the bit names with instructions
                                 ;* such as "sbr"/"cbr" (set/clear bit in register) and "sbrs"/"sbrc"
                                 ;* (skip if bit in register set/cleared). The following example illustrates
                                 ;* this:
                                 ;* 
                                 ;* in    r16,PORTB             ;read PORTB latch
                                 ;* sbr   r16,(1<<PB6)+(1<<PB5) ;set PB6 and PB5 (use masks, not bit#)
                                 ;* out   PORTB,r16             ;output to PORTB
                                 ;* 
                                 ;* in    r16,TIFR              ;read the Timer Interrupt Flag Register
                                 ;* sbrc  r16,TOV0              ;test the overflow flag (use bit#)
                                 ;* rjmp  TOV0_is_set           ;jump if set
                                 ;* ...                         ;otherwise do something else
                                 ;*************************************************************************
                                 
                                 #ifndef _TN45DEF_INC_
                                 #endif  /* _TN45DEF_INC_ */
                                 
                                 ; ***** END OF FILE ******************************************************
                                 
                                 ;
                                 ; Constants
                                 ;
                                 .EQU    DATA_NUM_BYTE = 64 ;Number of bytes that will be processed by the update function
                                 .EQU    STATE_NUM_BYTE = 64 ;Memory needed for hash function intermediate state (in bytes)
                                 .EQU    ADD_MEM_NUM_BYTE = 56 ;Optional additional memory for internal computation (in bytes)
                                 .EQU    HASH_NUM_BYTE = 32 ;Size of output hash (in bytes)
                                 
                                 .DSEG
000060                           	SRAM_DATA:		.BYTE DATA_NUM_BYTE
0000a0                           	SRAM_STATE:		.BYTE STATE_NUM_BYTE
0000e0                           	SRAM_ADD_MEM :	.BYTE ADD_MEM_NUM_BYTE
                                 
                                 .CSEG
                                 ;
                                 ; Registers declarations
                                 ;
                                 .LIST
                                 
                                 ; Initialization
                                 ; Init resets the counter and salt to zero, if a different salt is desired it should be set here
                                 ; In addition, Init loads the initialization vectors as first chain value
                                 
                                 init:	
                                 ;initialze the chain value by loading the initialization vector to it, h^0 <- IV
000008 e0f3                      	ldi zh, high(IV<<1)
000009 eeee                      	ldi zl, low (IV<<1)
00000a e0b0                      	ldi xh, high(SRAM_ADD_MEM)
00000b eea0                      	ldi xl, low (SRAM_ADD_MEM)
                                 
00000c e210                      	ldi temp2, 32
                                 loop_load_iv:
00000d 9105                      	lpm temp1, Z+
00000e 930d                      	st X+, temp1
00000f 951a                      	dec temp2
000010 f7e1                      	brne loop_load_iv
                                 
                                 ; set counter and salt to zero (if a different salt is required, it can be changed here)
000011 2700                      	clr temp1
000012 e110                      	ldi temp2, 16
                                 ; reset salt
                                 loop_load_salt:
000013 930d                      	st X+,temp1
000014 951a                      	dec temp2
000015 f7e9                      	brne loop_load_salt
                                 
000016 e018                      	ldi temp2,8
                                 ; reset counter
                                 loop_reset_counter:
000017 930d                      	st X+,temp1
000018 951a                      	dec temp2
000019 f7e9                      	brne loop_reset_counter
                                 
                                 ; clear T flag
00001a 94e8                      	clt
00001b 9508                      	ret
                                 
                                 ; Update Hash
                                 update:
                                 ;chain value is already present in the first 32 bytes of the state
                                 ; X points to the state
                                 ; Y points to the additional RAM
                                 ; Z points to the constants in flash memory
00001c e0b0                      	ldi xh, high(SRAM_STATE)
00001d eaa0                      	ldi xl, low (SRAM_STATE)
00001e e0d0                      	ldi yh, high(SRAM_ADD_MEM)
00001f eec0                      	ldi yl, low (SRAM_ADD_MEM)
000020 e0f4                      	ldi zh, high(CONSTANTS<<1)
000021 e0ee                      	ldi zl, low(CONSTANTS<<1)
                                 
                                 ;load chain value to state
                                 ; v(0)..v(7) <- h(0)..h(7)
000022 e220                      	ldi temp3, 32
                                 load_chain:
000023 9109                      	ld temp1, Y+
000024 930d                      	st X+, temp1
000025 952a                      	dec temp3
000026 f7e1                      	brne load_chain
                                 
                                 ;load salt and constants, xor their sum and store them to the state
                                 ; v(8)  <- s(0) xor c(0)
                                 ; v(9)  <- s(1) xor c(1)
                                 ; v(10) <- s(2) xor c(2)
                                 ; v(11) <- s(3) xor c(3)
                                 
000027 e120                      	ldi temp3, 16
                                 loop_xor_salt_constant:	
000028 9109                      	ld temp1, Y+	;load salt
000029 9115                      	lpm temp2, Z+	;load constant
00002a 2701                      	eor temp1,temp2	;xor salt and constant
00002b 930d                      	st X+,temp1		;store sum to state
00002c 952a                      	dec temp3
00002d f7d1                      	brne loop_xor_salt_constant
                                 
                                 ; increase counter by 512 except for when the T flag is set which indicates a call to update from final
                                 ; if T flag is set => do not increase counter
00002e f06e                      	brts no_counter
                                 ; else add 512=0x200 to the counter
00002f 9621                      	adiw Y, 1
000030 e002                      	ldi temp1, 0x02
000031 8118                      	ld temp2, Y
000032 0f10                      	add temp2, temp1
000033 9319                      	st Y+, temp2
                                 ; add possible carrys
000034 2700                      	clr temp1
000035 e016                      	ldi temp2, 6
                                 loop_inc_counter:
000036 8128                      	ld temp3, Y
000037 1f20                      	adc temp3, temp1
000038 9329                      	st Y+, temp3
000039 951a                      	dec temp2
00003a f7d9                      	brne loop_inc_counter
00003b 9728                      	sbiw Y,8
                                 
                                 ; fill the last part of the state by xoring counter (t) and constants
                                 ; v(12) <- t(0) xor c(4)
                                 ; v(13) <- t(0) xor c(5)
                                 ; v(14) <- t(1) xor c(6)
                                 ; v(15) <- t(1) xor c(7)
                                 no_counter:
00003c 9624                      	adiw Y, 4
00003d e022                      	ldi temp3, 2
                                 counter_xor_constant_loop0:	
00003e e042                      	ldi v_round, 2
                                 counter_xor_constant_loop1:
00003f e034                      	ldi i, 4
                                 counter_xor_constant_loop2:
000040 9105                      	lpm temp1, Z+
000041 911a                      	ld temp2, -Y
000042 2701                      	eor temp1, temp2
000043 930d                      	st X+, temp1
000044 953a                      	dec i
000045 f7d1                      	brne counter_xor_constant_loop2
000046 9624                      	adiw Y, 4
000047 954a                      	dec v_round
000048 f7b1                      	brne counter_xor_constant_loop1
000049 9624                      	adiw Y, 4
00004a 952a                      	dec temp3
00004b f791                      	brne counter_xor_constant_loop0
                                 
00004c 9728                      	sbiw Y, 8
                                 
                                 ; after initialization the compression function is iterated 14 times
                                 
00004d b70f                      	in temp1, SREG
00004e 930f                      	push temp1
                                 
00004f ef48                      	ldi v_round,-0x8
000050 94e8                      	clt
                                 
                                 do_round:
000051 2733                      	clr i
000052 e008                      	ldi temp1,0x8
000053 0f40                      	add v_round, temp1
000054 3540                      	cpi v_round, 0x50 ; do we have reached 10 iterations? if so reset v_round because sigma table is read again from the top
000055 f411                      	brne check_end
000056 9468                      	set
000057 2744                      	clr v_round
                                 
                                 check_end:
000058 f426                      	brtc start_round
000059 3240                      	cpi v_round,0x20 ; after another 4 rounds we have reached the required 14 iterations and have to continue with the round-finalization step
00005a f411                      	brne start_round
00005b 94e8                      	clt
00005c c027                      	rjmp finalize
                                 
                                 start_round:
                                 	
                                 ;call round function gi(a,b,c,d)
                                 ;set a,b,c,d according to:
                                 ;G0(v0 , v4 , v8 , v12) G1(v1 , v5 , v9 , v13) 
                                 ;G2(v2 , v6 , v10, v14) G3(v3 , v7 , v11, v15)
                                 ;G4(v0 , v5 , v10, v15) G5(v1 , v6 , v11, v12) 
                                 ;G6(v2 , v7 , v8 , v13) G7(v3 , v4 , v9 , v14)
                                 
                                 ; the parameters a,b,c,d for gi are loaded using the proposed method by Dag Arne Osvik (http://eprint.iacr.org/2012/156.pdf)
00005d e0b0                      	ldi xh, high(SRAM_STATE)
00005e eaa0                      	ldi xl, low (SRAM_STATE)
                                 
00005f e024                      	ldi temp3, 4
                                 g0_to_g3:
                                 ; G0, G1, G2, G3
000060 d0f0                      	rcall lc
000061 d094                      	rcall gi
000062 d125                      	rcall sc
000063 952a                      	dec temp3
000064 f7d9                      	brne g0_to_g3
                                 
                                 ; G4
000065 9658                      	adiw X, 24
000066 d103                      	rcall ld10
000067 d08e                      	rcall gi
000068 96d8                      	adiw X, 56
000069 d132                      	rcall st15
                                 
                                 ; G5
00006a 9698                      	adiw X, 40
00006b d0fe                      	rcall ld10
00006c 9698                      	adiw X, 40
00006d d115                      	rcall ld11
00006e d087                      	rcall gi
00006f 9718                      	sbiw X, 8
000070 d130                      	rcall st10
000071 9698                      	adiw X, 40
000072 d147                      	rcall st11
                                 
                                 ; G6
000073 9758                      	sbiw X, 24
000074 d0fa                      	rcall ld5
000075 9654                      	adiw X, 20
000076 d107                      	rcall ld6
000077 d07e                      	rcall gi
000078 975c                      	sbiw X, 28
000079 d12c                      	rcall st5
00007a 9654                      	adiw X, 20
00007b d139                      	rcall st6
                                 
                                 ; G7
00007c 979c                      	sbiw X, 44
00007d d0f6                      	rcall ld0
00007e d0fa                      	rcall ld1
00007f d076                      	rcall gi
000080 97d0                      	sbiw X, 48
000081 d129                      	rcall st0
000082 d12d                      	rcall st1
                                 
000083 cfcd                      	rjmp do_round
                                 
                                 finalize:
                                 ;finalization of current state
                                 ;h'0 = h0 eor s0 eor v0 eor v8
                                 ;h'1 = h1 eor s1 eor v1 eor v9
                                 ;h'2 = h2 eor s2 eor v2 eor v10
                                 ;h'3 = h3 eor s3 eor v3 eor v11
                                 ;h'4 = h4 eor s0 eor v4 eor v12
                                 ;h'5 = h5 eor s1 eor v5 eor v13
                                 ;h'6 = h6 eor s2 eor v6 eor v14
                                 ;h'7 = h7 eor s3 eor v7 eor v15
                                 
                                 ; X points to the state
                                 ; Y points to the salt
                                 ; Z points to the old chain value
                                 
000084 e0b0                      	ldi XH, high(SRAM_STATE)
000085 eaa0                      	ldi XL, low(SRAM_STATE)
000086 e0d1                      	ldi YH, high(SRAM_ADD_MEM+offset_salt)
000087 e0c0                      	ldi YL, low(SRAM_ADD_MEM+offset_salt)
000088 e0f0                      	ldi ZH, high(SRAM_ADD_MEM)
000089 eee0                      	ldi ZL, low(SRAM_ADD_MEM)
                                 
00008a e042                      	ldi v_round, 2
                                 loop_final1:
00008b e130                      	ldi i, 16
                                 loop_final2:
00008c 8100                      	ld temp1, Z ; h(i)	
00008d 9119                      	ld temp2, Y+ ; s(i)
00008e 912d                      	ld temp3, X+ ; v(i)
00008f 965f                      	adiw X, 31
000090 900d                      	ld a_hi, X+ ; v(i+8)
000091 9790                      	sbiw X, 32
000092 2701                      	eor temp1, temp2
000093 2520                      	eor temp3, a_hi
000094 2702                      	eor temp1, temp3
000095 9301                      	st Z+, temp1
000096 953a                      	dec i
000097 f7a1                      	brne loop_final2
000098 9760                      	sbiw Y, 16
000099 954a                      	dec v_round
00009a f781                      	brne loop_final1
                                 
                                 return:
00009b 910f                      	pop temp1
00009c bf0f                      	out SREG, temp1
                                 
00009d 9508                      	ret
                                 
                                 ; Final
                                 ;	r24 contains the number of bytes passed to the final function.
                                 final:
                                 ; X points to the data block which need padding
                                 ; Y points to the counter
00009e e0b0                      	ldi xh, high(SRAM_DATA)
00009f e6a0                      	ldi xl, low (SRAM_DATA)
0000a0 e0d1                      	ldi yh, high(SRAM_ADD_MEM+offset_counter)
0000a1 e1c0                      	ldi yl, low (SRAM_ADD_MEM+offset_counter)
                                 
                                 ; if size is zero last block was a full block and now an additional block is required that just contains out of padding 0x80...01<counter>
0000a2 3080                      	cpi r24, 0
0000a3 f019                      	breq full_padding
                                 
                                 ; if size is >= 56 the padding cannot be done in place and an additional block is required
0000a4 3388                      	cpi r24, 56
0000a5 f418                      	brsh padd_and_new_block
                                 ; else the padding fits into the current message block	
0000a6 c01d                      	rjmp in_place_padding
                                 
                                 full_padding:
                                 ; set T flag (indicates to not increase the counter) since no message bytes are present
0000a7 9468                      	set
0000a8 c01b                      	rjmp in_place_padding
                                 
                                 padd_and_new_block:
                                 ; go to the byte just after the last message byte and append 0x80
0000a9 2700                      	clr temp1
0000aa 2f38                      	mov i, r24
0000ab 0fa3                      	add xl, i
0000ac 1fb0                      	adc xh, temp1
                                 
0000ad e810                      	ldi temp2, 0b10000000
0000ae 931d                      	st X+, temp2
0000af 9533                      	inc i
                                 ; if message block is now full we are done, else padd with zeros until message block is full
0000b0 3430                      	cpi i, 64
0000b1 f021                      	breq done_padd_00
                                 
                                 padd_00:
0000b2 930d                      	st X+, temp1
0000b3 9533                      	inc i
0000b4 3430                      	cpi i, 64
0000b5 f7e1                      	brne padd_00
                                 
                                 done_padd_00:
                                 ; increase the counter by the remaining message bytes
0000b6 d108                      	rcall load_counter_add_r24
                                 ; store the counter back to RAM
0000b7 d121                      	rcall store_counter
                                 ; call the update function
0000b8 9468                      	set
0000b9 df62                      	rcall update
                                 ; now no message bytes are remaining, but a new block with only the padding is hashed
0000ba e080                      	ldi r24, 0
0000bb e0b0                      	ldi xh, high(SRAM_DATA)
0000bc e6a0                      	ldi xl, low (SRAM_DATA)
0000bd e0d1                      	ldi yh, high(SRAM_ADD_MEM+offset_counter)
0000be e1c0                      	ldi yl, low (SRAM_ADD_MEM+offset_counter)
                                 
0000bf 2f38                      	mov i, r24
0000c0 2700                      	clr temp1
0000c1 930d                      	st X+, temp1
0000c2 9468                      	set
0000c3 c00c                      	rjmp padd_0
                                 
                                 in_place_padding:
                                 ; in this case the padding fits into the current block write 0x80 just after the last message byte,
                                 ; or 0x81 if only one block is left before the counter has to be appended
0000c4 2f38                      	mov i, r24
                                 	
0000c5 2700                      	clr temp1
0000c6 0fa8                      	add xl, r24
0000c7 1fb0                      	adc xh, temp1
                                 
0000c8 3337                      	cpi i,55
0000c9 f419                      	brne padd_usual
                                 
0000ca e801                      	ldi temp1,0b10000001
0000cb 930c                      	st X, temp1
0000cc c009                      	rjmp padd_counter
                                 	
                                 padd_usual:
0000cd e800                      	ldi temp1,0b10000000
0000ce 930d                      	st X+, temp1
                                 
0000cf 2700                      	clr temp1	
                                 padd_0:
                                 ; padd with zeros until we have reached the position where the counter has to be appended
0000d0 930d                      	st X+, temp1
0000d1 9533                      	inc i
0000d2 3337                      	cpi i, 55
0000d3 f7e1                      	brne padd_0
                                 	
0000d4 e001                      	ldi temp1, 0b00000001
0000d5 930e                      	st -X, temp1
                                 
                                 padd_counter:
                                 ; now append the counter
0000d6 d0e8                      	rcall load_counter_add_r24
                                 
0000d7 9611                      	adiw X, 1
0000d8 924d                      	st X+,b_hi
0000d9 925d                      	st X+,b_mh
0000da 926d                      	st X+,b_ml
0000db 927d                      	st X+,b_lo
0000dc 920d                      	st X+,a_hi
0000dd 921d                      	st X+,a_mh
0000de 922d                      	st X+,a_ml
0000df 923d                      	st X+,a_lo
                                 ; if T flag is clear call update
                                 ; else set counter to zero and then call update
0000e0 f446                      	brtc final_call
0000e1 2433                      	clr a_lo
0000e2 2422                      	clr a_ml
0000e3 2411                      	clr a_mh
0000e4 2400                      	clr a_hi
0000e5 2477                      	clr b_lo
0000e6 2466                      	clr b_ml
0000e7 2455                      	clr b_mh
0000e8 2444                      	clr b_hi
                                 	
                                 final_call:
0000e9 d0ef                      	rcall store_counter
0000ea 9468                      	set
0000eb df30                      	rcall update
                                 
                                 ; now copy the hash value to the state where it has to be placed according to the interface
                                 copy_hash_value:
0000ec e0b0                      	ldi xh, high(SRAM_STATE)
0000ed eaa0                      	ldi xl, low (SRAM_STATE)
0000ee e0d0                      	ldi yh, high(SRAM_ADD_MEM)
0000ef eec0                      	ldi yl, low (SRAM_ADD_MEM)
                                 
0000f0 e200                      	ldi temp1, 32
                                 loop_copy_hash_value:
0000f1 9119                      	ld temp2, Y+
0000f2 931d                      	st X+, temp2
0000f3 950a                      	dec temp1
0000f4 f7e1                      	brne loop_copy_hash_value
                                 
0000f5 9508                      	ret
                                 
                                 ; ****************
                                 ; Helper functions
                                 ; ****************
                                 
                                 ;roundfunction gi
                                 ;gi(a,b,c,d)
                                 ;a =  a + b + (m_sigr(2i) XOR c_sigr(2i+1))
                                 ;d =  (d XOR a) >> 16
                                 ;c =  c + d
                                 ;b =  (b XOR c) >> 12
                                 ;a =  a + b + (m sigr(2i+1) XOR c sigr(2i))
                                 ;d =  (d XOR a) >> 8
                                 ;c =  c + d
                                 ;b =  (b XOR c) >> 7
                                 
                                 gi:
0000f6 e0d0                      	ldi yh, high(SRAM_DATA)
0000f7 e6c0                      	ldi yl, low(SRAM_DATA)
0000f8 e0f4                      	ldi zh, high(SIGMA<<1)
0000f9 e4ee                      	ldi zl, low(SIGMA<<1)	
                                 
                                 ;calculate offset in sigma table
0000fa 2f03                      	mov temp1, i
                                 	;lsl temp1
0000fb 0f04                      	add temp1,v_round
                                 ;add offset to sigma pointer
0000fc 0fe0                      	add zl, temp1
0000fd 2700                      	clr temp1
0000fe 1ff0                      	adc zh, temp1
                                 ;read sigma_r(2i)
0000ff 9164                      	lpm sigr2,Z
000100 2f56                      	mov sigr1, sigr2
000101 706f                      	andi sigr2, 0x0F
000102 9552                      	swap sigr1
000103 705f                      	andi sigr1, 0x0F
                                 ;read sigma_r(2i+1)
                                 	;lpm sigr2,Z
                                 ;i=i+1 for the next round
000104 9533                      	inc i
                                 
                                 ; set Z pointer to CONSTANTS
000105 e0f4                      	ldi zh, high(CONSTANTS<<1)
000106 e0ee                      	ldi zl, low(CONSTANTS<<1)
                                 
                                 ;calculate a =  a + b + (m_sigr(2i) XOR c_sigr(2i+1))
                                 
                                 ;load constant c_sigr(2i+1) and xor with m_sigr(2i)
000107 0f66                      	lsl sigr2
000108 0f66                      	lsl sigr2
000109 0f55                      	lsl sigr1
00010a 0f55                      	lsl sigr1
                                 
00010b 0fe6                      	add zl,sigr2
00010c 1ff0                      	adc zh,temp1
                                 
00010d 0fc5                      	add yl,sigr1
00010e 1fd0                      	adc yh,temp1
                                 
00010f d0d2                      	rcall a_b_msg_const
                                 
                                 ; d = (d xor a) >> 16
                                 ; 32 bit xor of d and a, result is stored in d
000110 24f3                      	eor d_lo,a_lo
000111 24e2                      	eor d_ml,a_ml
000112 24d1                      	eor d_mh,a_mh
000113 24c0                      	eor d_hi,a_hi
                                 ; 16 bit rotation is done by swapping
000114 0186                      	movw temp1,d_hi
000115 0167                      	movw d_hi,d_ml
000116 0178                      	movw d_ml,temp1
                                 
                                 ; c = c+d
                                 ; 32 bit add of c and d, result is stored in c
000117 0cbf                      	add c_lo,d_lo
000118 1cae                      	adc c_ml,d_ml
000119 1c9d                      	adc c_mh,d_mh
00011a 1c8c                      	adc c_hi,d_hi
                                 
                                 ; b = (b xor c) >> 12
                                 ; 32 bit xor of b and c, result is stored in b
00011b 247b                      	eor b_lo,c_lo
00011c 246a                      	eor b_ml,c_ml
00011d 2459                      	eor b_mh,c_mh
00011e 2448                      	eor b_hi,c_hi
                                 
                                 ; >>>>16 + <<<<4 = >>>>12
                                 ;	>>>>16
00011f 0182                      	movw temp1,b_hi
000120 0123                      	movw b_hi,b_ml
000121 0138                      	movw b_ml,temp1
                                 ;	<<<<4
000122 e004                      	ldi temp1, 4
000123 2711                      	clr temp2
                                 loop_shift_4:
000124 0c77                      	lsl b_lo
000125 1c66                      	rol b_ml
000126 1c55                      	rol b_mh
000127 1c44                      	rol b_hi
000128 1e71                      	adc b_lo,temp2
000129 950a                      	dec temp1
00012a f7c9                      	brne loop_shift_4
                                 
                                 ;insert a =  a + b + (m sigr(2i+1) XOR c sigr(2i))
00012b e0d0                      	ldi yh, high(SRAM_DATA)
00012c e6c0                      	ldi yl, low(SRAM_DATA)
00012d e0f4                      	ldi zh, high(CONSTANTS<<1)
00012e e0ee                      	ldi zl, low(CONSTANTS<<1)
                                 
00012f 0fe5                      	add zl, sigr1
000130 1ff1                      	adc zh, temp2
                                 
000131 0fc6                      	add yl, sigr2
000132 1fd1                      	adc yh, temp2
                                 
000133 d0ae                      	rcall a_b_msg_const
                                 
                                 ; d = (d xor a) >> 8
                                 ; 32 bit xor of d and a, result is stored in d
000134 24f3                      	eor d_lo,a_lo
000135 24e2                      	eor d_ml,a_ml
000136 24d1                      	eor d_mh,a_mh
000137 24c0                      	eor d_hi,a_hi
                                 
                                 ; 8 bit rotation is done by swapping
000138 2d1d                      	mov temp2,d_mh
000139 2cdc                      	mov d_mh,d_hi
00013a 2ccf                      	mov d_hi,d_lo
00013b 2cfe                      	mov d_lo,d_ml
00013c 2ee1                      	mov d_ml,temp2
                                 
                                 ; 32 bit add of c and d, result is stored in c
00013d 0cbf                      	add c_lo,d_lo
00013e 1cae                      	adc c_ml,d_ml
00013f 1c9d                      	adc c_mh,d_mh
000140 1c8c                      	adc c_hi,d_hi
                                 
                                 ; b = (b xor c) >> 7
                                 ; 32 bit xor of b and c, result is stored in b
000141 247b                      	eor b_lo,c_lo
000142 246a                      	eor b_ml,c_ml
000143 2459                      	eor b_mh,c_mh
000144 2448                      	eor b_hi,c_hi
                                 ; >>>>7 = >>>>8 + <<<<1
000145 2d15                      	mov temp2,b_mh
000146 2c54                      	mov b_mh,b_hi
000147 2c47                      	mov b_hi,b_lo
000148 2c76                      	mov b_lo,b_ml
000149 2e61                      	mov b_ml,temp2
                                 ; plus <<<<1
00014a 0c77                      	lsl b_lo
00014b 1c66                      	rol b_ml
00014c 1c55                      	rol b_mh
00014d 1c44                      	rol b_hi
00014e 2700                      	clr temp1
00014f 1e70                      	adc b_lo,temp1
                                 
000150 9508                      ret
                                 
                                 ; load and store functions to load the parameters a,b,c,d - see http://eprint.iacr.org/2012/156.pdf by Dag Arne Osvik
                                 lc:
000151 900d                      	ld a_hi,X+
000152 901d                      	ld a_mh,X+
000153 902d                      	ld a_ml,X+
000154 903d                      	ld a_lo,X+
000155 961c                      	adiw xl,12
000156 904d                      	ld b_hi,X+
000157 905d                      	ld b_mh,X+
000158 906d                      	ld b_ml,X+
000159 907d                      	ld b_lo,X+
00015a 961c                      	adiw xl,12
00015b 908d                      	ld c_hi,X+
00015c 909d                      	ld c_mh,X+
00015d 90ad                      	ld c_ml,X+
00015e 90bd                      	ld c_lo,X+
00015f 961c                      	adiw xl,12
000160 90cd                      	ld d_hi,X+
000161 90dd                      	ld d_mh,X+
000162 90ed                      	ld d_ml,X+
000163 90fd                      	ld d_lo,X+
000164 9508                      	ret
                                 
                                 ld15:
000165 90cd                      	ld d_hi,X+
000166 90dd                      	ld d_mh,X+
000167 90ed                      	ld d_ml,X+
000168 90fd                      	ld d_lo,X+
000169 9758                      	sbiw X, 24
                                 
                                 ld10:	
00016a 908d                      	ld c_hi,X+
00016b 909d                      	ld c_mh,X+
00016c 90ad                      	ld c_ml,X+
00016d 90bd                      	ld c_lo,X+ 
00016e 9758                      	sbiw X, 24
                                 
                                 ld5: 
00016f 904d                      	ld b_hi,X+
000170 905d                      	ld b_mh,X+
000171 906d                      	ld b_ml,X+
000172 907d                      	ld b_lo,X+
000173 9758                      	sbiw X, 24
                                 
                                 ld0:
000174 900d                      	ld a_hi,X+
000175 901d                      	ld a_mh,X+
000176 902d                      	ld a_ml,X+
000177 903d                      	ld a_lo,X+
000178 9508                      	ret
                                 
                                 ld1:
000179 904d                      	ld b_hi,X+
00017a 905d                      	ld b_mh,X+
00017b 906d                      	ld b_ml,X+
00017c 907d                      	ld b_lo,X+
00017d 9650                      	adiw X, 16
                                 
                                 ld6:
00017e 908d                      	ld c_hi,X+
00017f 909d                      	ld c_mh,X+
000180 90ad                      	ld c_ml,X+
000181 90bd                      	ld c_lo,X+ 
000182 9650                      	adiw X, 16
                                 
                                 ld11:
000183 90cd                      	ld d_hi,X+
000184 90dd                      	ld d_mh,X+
000185 90ed                      	ld d_ml,X+
000186 90fd                      	ld d_lo,X+
000187 9508                      	ret
                                 
                                 sc:
000188 92fe                      	st -X,d_lo
000189 92ee                      	st -X,d_ml
00018a 92de                      	st -X,d_mh
00018b 92ce                      	st -X,d_hi
00018c 971c                      	sbiw xl,12
00018d 92be                      	st -X,c_lo
00018e 92ae                      	st -X,c_ml
00018f 929e                      	st -X,c_mh
000190 928e                      	st -X,c_hi
000191 971c                      	sbiw xl,12
000192 927e                      	st -X,b_lo
000193 926e                      	st -X,b_ml
000194 925e                      	st -X,b_mh
000195 924e                      	st -X,b_hi
000196 9750                      	sbiw xl,16
000197 920d                      	st X+,a_hi
000198 921d                      	st X+,a_mh
000199 922d                      	st X+,a_ml
00019a 923d                      	st X+,a_lo
00019b 9508                      	ret
                                 
                                 st15:
00019c 92cd                      	st X+, d_hi
00019d 92dd                      	st X+, d_mh
00019e 92ed                      	st X+, d_ml
00019f 92fd                      	st X+, d_lo
0001a0 9758                      	sbiw X, 24
                                 
                                 st10:
0001a1 928d                      	st X+, c_hi
0001a2 929d                      	st X+, c_mh
0001a3 92ad                      	st X+, c_ml
0001a4 92bd                      	st X+, c_lo
0001a5 9758                      	sbiw X, 24
                                 
                                 st5:
0001a6 924d                      	st X+, b_hi
0001a7 925d                      	st X+, b_mh
0001a8 926d                      	st X+, b_ml
0001a9 927d                      	st X+, b_lo
0001aa 9758                      	sbiw X, 24
                                 
                                 st0:
0001ab 920d                      	st X+, a_hi
0001ac 921d                      	st X+, a_mh
0001ad 922d                      	st X+, a_ml
0001ae 923d                      	st X+, a_lo
0001af 9508                      	ret
                                 
                                 st1:
0001b0 924d                      	st X+, b_hi
0001b1 925d                      	st X+, b_mh
0001b2 926d                      	st X+, b_ml
0001b3 927d                      	st X+, b_lo
0001b4 9650                      	adiw X, 16
                                 
                                 st6:
0001b5 928d                      	st X+, c_hi
0001b6 929d                      	st X+, c_mh
0001b7 92ad                      	st X+, c_ml
0001b8 92bd                      	st X+, c_lo
0001b9 9650                      	adiw X, 16
                                 
                                 st11:
0001ba 92cd                      	st X+, d_hi
0001bb 92dd                      	st X+, d_mh
0001bc 92ed                      	st X+, d_ml
0001bd 92fd                      	st X+, d_lo
0001be 9508                      	ret
                                 
                                 ld_a:
                                 ;	ld a_hi,X+
                                 ;	ld a_mh,X+
                                 ;	ld a_ml,X+
                                 ;	ld a_lo,X+
                                 
                                 ld_b:
                                 ;	ld b_hi,X+
                                 ;	ld b_mh,X+
                                 ;	ld b_ml,X+
                                 ;	ld b_lo,X+
                                 
                                 ; this function loads the counter and adds the content of r24 to it
                                 load_counter_add_r24:
0001bf 9039                      	ld a_lo,Y+
0001c0 9029                      	ld a_ml,Y+
0001c1 9019                      	ld a_mh,Y+
0001c2 9009                      	ld a_hi,Y+
0001c3 9079                      	ld b_lo,Y+
0001c4 9069                      	ld b_ml,Y+
0001c5 9059                      	ld b_mh,Y+
0001c6 9049                      	ld b_hi,Y+
                                 
0001c7 2711                      	clr temp2
0001c8 2f08                      	mov temp1, r24
0001c9 0f00                      	lsl temp1
0001ca 1f11                      	rol temp2
0001cb 0f00                      	lsl temp1
0001cc 1f11                      	rol temp2
0001cd 0f00                      	lsl temp1
0001ce 1f11                      	rol temp2
                                 	
0001cf 2722                      	clr temp3
0001d0 0e30                      	add a_lo, temp1
0001d1 1e21                      	adc a_ml,temp2
0001d2 1e12                      	adc a_mh,temp3
0001d3 1e02                      	adc a_hi,temp3
0001d4 1e72                      	adc b_lo,temp3
0001d5 1e62                      	adc b_ml,temp3
0001d6 1e52                      	adc b_mh,temp3
0001d7 1e42                      	adc b_hi,temp3
0001d8 9508                      	ret
                                 
                                 ; this function stores the counter back to RAM
                                 store_counter:
0001d9 924a                      	st -Y,b_hi
0001da 925a                      	st -Y,b_mh
0001db 926a                      	st -Y,b_ml
0001dc 927a                      	st -Y,b_lo
0001dd 920a                      	st -Y,a_hi
0001de 921a                      	st -Y,a_mh
0001df 922a                      	st -Y,a_ml
0001e0 923a                      	st -Y,a_lo	
0001e1 9508                      	ret
                                 
                                 ; this function is part of the computation a = a+b+m+c in gi
                                 a_b_msg_const:
0001e2 9175                      	lpm eormc_hi,Z+
0001e3 9109                      	ld temp1,Y+
0001e4 2770                      	eor eormc_hi,temp1
                                 		
0001e5 9185                      	lpm eormc_mh,Z+
0001e6 9109                      	ld temp1,Y+
0001e7 2780                      	eor eormc_mh,temp1
                                 	
0001e8 9195                      	lpm eormc_ml,Z+
0001e9 9109                      	ld temp1,Y+
0001ea 2790                      	eor eormc_ml,temp1
                                 	
0001eb 9105                      	lpm temp1,Z+
0001ec 9119                      	ld temp2,Y+
0001ed 2701                      	eor temp1,temp2
                                 
0001ee 0e30                      	add a_lo,temp1
0001ef 1e29                      	adc a_ml,eormc_ml
0001f0 1e18                      	adc a_mh,eormc_mh
0001f1 1e07                      	adc a_hi,eormc_hi	
                                 
                                 ; 32 bit add of a and b, result is stored in a
0001f2 0c37                      	add a_lo,b_lo
0001f3 1c26                      	adc a_ml,b_ml
0001f4 1c15                      	adc a_mh,b_mh
0001f5 1c04                      	adc a_hi,b_hi
0001f6 9508                      	ret
                                 
                                 ; IV's needed for initialization require 8x32Bit = 256Bit = 8x4Byte = 32 Byte
                                 IV:
0001f7 096a
0001f8 67e6                      	.db 0x6A,0x09,0xE6,0x67
0001f9 67bb
0001fa 85ae                      	.db 0xBB,0x67,0xAE,0x85
0001fb 6e3c
0001fc 72f3                      	.db 0x3C,0x6E,0xF3,0x72
0001fd 4fa5
0001fe 3af5                      	.db 0xA5,0x4F,0xF5,0x3A
0001ff 0e51
000200 7f52                      	.db 0x51,0x0E,0x52,0x7F
000201 059b
000202 8c68                      	.db 0x9B,0x05,0x68,0x8C
000203 831f
000204 abd9                      	.db 0x1F,0x83,0xD9,0xAB
000205 e05b
000206 19cd                      	.db 0x5B,0xE0,0xCD,0x19
                                 
                                 
                                 ;Constants that are used in every round 16x32 Bit = 512Bit = 16x4Byte = 64 Byte
                                 CONSTANTS:
000207 3f24
000208 886a                      	.db 0x24,0x3F,0x6A,0x88
000209 a385
00020a d308                      	.db 0x85,0xA3,0x08,0xD3
00020b 1913
00020c 2e8a                      	.db 0x13,0x19,0x8A,0x2E
00020d 7003
00020e 4473                      	.db 0x03,0x70,0x73,0x44
00020f 09a4
000210 2238                      	.db 0xA4,0x09,0x38,0x22
000211 9f29
000212 d031                      	.db 0x29,0x9F,0x31,0xD0
000213 2e08
000214 98fa                      	.db 0x08,0x2E,0xFA,0x98
000215 4eec
000216 896c                      	.db 0xEC,0x4E,0x6C,0x89
000217 2845
000218 e621                      	.db 0x45,0x28,0x21,0xE6
000219 d038
00021a 7713                      	.db 0x38,0xD0,0x13,0x77
00021b 54be
00021c cf66                      	.db 0xBE,0x54,0x66,0xCF
00021d e934
00021e 6c0c                      	.db 0x34,0xE9,0x0C,0x6C
00021f acc0
000220 b729                      	.db 0xC0,0xAC,0x29,0xB7
000221 7cc9
000222 dd50                      	.db 0xC9,0x7C,0x50,0xDD
000223 843f
000224 b5d5                      	.db 0x3F,0x84,0xD5,0xB5
000225 47b5
000226 1709                      	.db 0xB5,0x47,0x09,0x17
                                 
                                 ; Sigma round-dependend: 
                                 ; when stored with one sigma value per byte 10x16x8 Bit = 1280 Bit = 160x1 Byte = 160 Byte
                                 ; here merged to fit two sigma values in one byte -> reduced to 10x16x4 Bit = 640 Bit = 80x1 Byte = 80 Byte
                                 SIGMA:
000227 2301
000228 6745
000229 ab89
00022a efcd                      	.db 0x01,0x23,0x45,0x67,0x89,0xab,0xcd,0xef
00022b 48ea
00022c d69f
00022d 021c
00022e 53b7                      	.db 0xea,0x48,0x9f,0xd6,0x1c,0x02,0xb7,0x53
00022f c0b8
000230 fd52
000231 36ae
000232 9471                      	.db 0xb8,0xc0,0x52,0xfd,0xae,0x36,0x71,0x94
000233 3179
000234 bedc
000235 5a26
000236 f840                      	.db 0x79,0x31,0xdc,0xbe,0x26,0x5a,0x40,0xf8
000237 5790
000238 af24
000239 bce1
00023a 3d68                      	.db 0x90,0x57,0x24,0xaf,0xe1,0xbc,0x68,0x3d
00023b 6a2c
00023c 830b
00023d 754d
00023e 19fe                      	.db 0x2c,0x6a,0x0b,0x83,0x4d,0x75,0xfe,0x19
00023f 1fc5
000240 4aed
000241 6307
000242 8b92                      	.db 0xc5,0x1f,0xed,0x4a,0x07,0x63,0x92,0x8b
000243 7edb
000244 39c1
000245 f450
000246 2a86                      	.db 0xdb,0x7e,0xc1,0x39,0x50,0xf4,0x86,0x2a
000247 e96f
000248 08b3
000249 d7c2
00024a a514                      	.db 0x6f,0xe9,0xb3,0x08,0xc2,0xd7,0x14,0xa5
00024b 84a2
00024c 1576
00024d 9efb
00024e d03c                      #else
                                 #endif
                                 
                                 
                                 .cseg
                                 
                                 
                                 ;******************** MAIN (START) *******************************
                                 main:
                                 	; initialisation
00024f e0b1                      	ldi		XH, high(to_hash_size)
000250 e1a8                      	ldi		XL, low(to_hash_size)
000251 e090                      	ldi		r25, high(msg_size)		; Number of bytes to hash is DATA_NUM_BYTE at initialisation
000252 e081                      	ldi		r24, low(msg_size)
000253 939d                      	st		X+, r25
000254 938c                      	st		X, r24
                                 
000255 ddb2                      	rcall	init
                                 
                                 
                                 main_hash_loop:
                                 	;Load remaining bytes to hash (to_hash_size) from SRAM
000256 e0b1                      	ldi		XH, high(to_hash_size)
000257 e1a8                      	ldi		XL, low(to_hash_size)
000258 919d                      	ld		r25, X+					;r25:24 = Number of remaining bytes to hash before update
000259 918c                      	ld		r24, X
                                 
00025a 01ec                      	movw	Y, r25:r24
00025b 54c0                      	subi	YL, low(DATA_NUM_BYTE)
00025c 40d0                      	sbci	YH, high(DATA_NUM_BYTE)
00025d f408                      	brsh	main_upd_call		; If remaining bytes to hash >= DATA_NUM_BYTE,
                                 								; we call update again.
00025e c00e                      	rjmp	main_final_call		; Otherwise we call the final routine.
                                 
                                 	main_upd_call:
                                 		;Store updated 2hash_size in SRAM
00025f e0b1                      		ldi		XH, high(to_hash_size)
000260 e1a8                      		ldi		XL, low(to_hash_size)
000261 93dd                      		st		X+, YH
000262 93cc                      		st		X, YL
                                 		;Store ith message block into SRAM
000263 2711                      		clr		r17
000264 e0b0                      		ldi 	XH, high(SRAM_DATA)
000265 e6a0                      		ldi 	XL, low(SRAM_DATA)
000266 e420                      		ldi		r18, DATA_NUM_BYTE
                                 		store_msg_loop:
000267 931d                      			st		X+, r17
000268 9513                      			inc		r17
000269 952a                      			dec		r18
00026a f7e1                      			brne	store_msg_loop		
                                 		
00026b ddb0                      		rcall	update
00026c cfe9                      		rjmp	main_hash_loop
                                 
                                 	main_final_call:
                                 		;Store ith message block into SRAM
00026d 2711                      		clr		r17
00026e e0b0                      		ldi 	XH, high(SRAM_DATA)
00026f e6a0                      		ldi 	XL, low(SRAM_DATA)
000270 2f28                      		mov		r18, r24
000271 3020                      		cpi		r18,0
000272 f021                      		brbs	1, final_empty_block
                                 
                                 		store_end_msg_loop:
000273 931d                      			st		X+, r17
000274 9513                      			inc		r17
000275 952a                      			dec		r18
000276 f7e1                      			brne	store_end_msg_loop	
                                 			
                                 	final_empty_block:
000277 de26                      		rcall	final
000278 cfd6                      		rjmp	main
                                 
                                 
                                 
                                 .dseg
000118                           	to_hash_size: .byte 2
                                 
                                 ;******************** MAIN (END) *********************************
                                 


RESOURCE USE INFORMATION
------------------------

Notice:
The register and instruction counts are symbol table hit counts,
and hence implicitly used resources are not counted, eg, the
'lpm' instruction without operands implicitly uses r0 and z,
none of which are counted.

x,y,z are separate entities in the symbol table and are
counted separately from r26..r31 here.

.dseg memory usage only counts static data declared with .byte

"ATtiny45" register use summary:
x  : 145 y  :  37 z  :  10 r0 :  15 r1 :  13 r2 :  13 r3 :  13 r4 :  20 
r5 :  18 r6 :  20 r7 :  20 r8 :  10 r9 :  10 r10:  10 r11:  10 r12:  14 
r13:  12 r14:  14 r15:  12 r16:  75 r17:  42 r18:  26 r19:  18 r20:  10 
r21:   7 r22:   7 r23:   3 r24:  16 r25:   7 r26:  20 r27:  14 r28:  11 
r29:  11 r30:   9 r31:  13 
Registers used: 35 out of 35 (100.0%)

"ATtiny45" instruction use summary:
.lds  :   0 .sts  :   0 adc   :  29 add   :  15 adiw  :  20 and   :   0 
andi  :   2 asr   :   0 bclr  :   0 bld   :   0 brbc  :   0 brbs  :   1 
brcc  :   0 brcs  :   0 break :   0 breq  :   2 brge  :   0 brhc  :   0 
brhs  :   0 brid  :   0 brie  :   0 brlo  :   0 brlt  :   0 brmi  :   0 
brne  :  21 brpl  :   0 brsh  :   2 brtc  :   2 brts  :   1 brvc  :   0 
brvs  :   0 bset  :   0 bst   :   0 cbi   :   0 cbr   :   0 clc   :   0 
clh   :   0 cli   :   1 cln   :   0 clr   :  23 cls   :   0 clt   :   3 
clv   :   0 clz   :   0 com   :   0 cp    :   0 cpc   :   0 cpi   :   9 
cpse  :   0 dec   :  16 eor   :  25 icall :   0 ijmp  :   0 in    :   1 
inc   :   6 ld    :  68 ldd   :   0 ldi   :  78 lds   :   0 lpm   :   9 
lsl   :   9 lsr   :   0 mov   :  17 movw  :   7 neg   :   0 nop   :   0 
or    :   0 ori   :   0 out   :   4 pop   :   1 push  :   1 rcall :  32 
ret   :  13 reti  :   0 rjmp  :  10 rol   :   9 ror   :   0 sbc   :   0 
sbci  :   1 sbi   :   0 sbic  :   0 sbis  :   0 sbiw  :  18 sbr   :   0 
sbrc  :   0 sbrs  :   0 sec   :   0 seh   :   0 sei   :   0 sen   :   0 
ser   :   0 ses   :   0 set   :   5 sev   :   0 sez   :   0 sleep :   0 
spm   :   0 st    :  83 std   :   0 sts   :   0 sub   :   0 subi  :   1 
swap  :   1 tst   :   0 wdr   :   0 
Instructions used: 37 out of 105 (35.2%)

"ATtiny45" memory use summary [bytes]:
Segment   Begin    End      Code   Data   Used    Size   Use%
---------------------------------------------------------------
[.cseg] 0x000000 0x0004f2   1090    176   1266    4096  30.9%
[.dseg] 0x000060 0x00011a      0    186    186     256  72.7%
[.eseg] 0x000000 0x000000      0      0      0     256   0.0%

Assembly complete, 0 errors, 0 warnings
